#
# Copyright 2023 Valkyrie Systems Corporation
#
# Licensed under MIT License.  See LICENSE.
#
import datetime
import itertools
import logging
import pathlib

import numpy as np
import pytest

import sarpy.geometry.geocoords
import sarpy.io.complex.sicd_elements.SCPCOA
from sarpy.io.complex.sicd_elements.SICD import SICDType
import sarpy.io.product.sidd3_elements.ExploitationFeatures as ef3


def test_exploitation_calculator():
    scp = sarpy.geometry.geocoords.geodetic_to_ecf([0, 0, 0])
    geom_calc = sarpy.io.complex.sicd_elements.SCPCOA.GeometryCalculator(
        SCP=scp,
        ARPPos=scp + [1000, 0, -1000],
        ARPVel=np.asarray([0, 100, 0]),
    )
    calc3 = ef3.ExploitationCalculator(geom_calc,
                                       # "Shadows Up"
                                       row_vector=np.asarray([0, 0, -1]),  # South
                                       col_vector=np.asarray([0, 1, 0]))   # East
    assert calc3.North == pytest.approx(270)
    assert calc3.Shadow.Angle == pytest.approx(270)
    assert calc3.Layover.Angle == pytest.approx(90)
    assert calc3.MultiPath == pytest.approx(90)
    assert calc3.GroundTrack == pytest.approx(0)


SINGLE_SICD_POLS = ('V', 'H', 'X', 'Y', 'S', 'E', 'RHC', 'LHC', 'OTHER', 'OTHER_CUSTOM')
POLS = SINGLE_SICD_POLS + ('UNKNOWN',)

@pytest.mark.parametrize(('txpol', 'rcvpol'), itertools.product(POLS, POLS))
def test_txrcvpolarization(txpol, rcvpol, caplog):
    with caplog.at_level(logging.INFO, 'sarpy.io.xml.descriptors'):
        ef3.TxRcvPolarizationType(TxPolarization=txpol, RcvPolarization=rcvpol)
        assert not caplog.records


@pytest.mark.parametrize(('txpol', 'rcvpol'), itertools.product(SINGLE_SICD_POLS, SINGLE_SICD_POLS))
def test_txrcvpolarization_from_sicd_nominal(txpol, rcvpol):
    sicd_str = f'{txpol}:{rcvpol}'
    txp = ef3.TxRcvPolarizationType.from_sicd_value(sicd_str)
    assert txp.TxPolarization == txpol
    assert txp.RcvPolarization == rcvpol


@pytest.mark.parametrize(('sicd_str', 'expected'), 
                         [(None, ('UNKNOWN', 'UNKNOWN')),
                          ('OTHER', ('OTHER', 'OTHER')),
                          ('UNKNOWN', ('UNKNOWN', 'UNKNOWN')),
                         ])
def test_txrcvpolarization_from_sicd_other(sicd_str, expected):
    txp = ef3.TxRcvPolarizationType.from_sicd_value(sicd_str)
    assert txp.TxPolarization == expected[0]
    assert txp.RcvPolarization == expected[1]


def test_txrcvpolarization_from_sicd_error():
    with pytest.raises(TypeError):
        ef3.TxRcvPolarizationType.from_sicd_value(0)


def test_exploitation_features_collection_information(caplog):
    efci = ef3.ExploitationFeaturesCollectionInformationType()
    efci.LocalDateTime = None
    assert efci.LocalDateTime is None
    efci.LocalDateTime = datetime.datetime(2023, 1, 1, 12, 34, 56, 789000)
    assert efci.LocalDateTime == '2023-01-01T12:34:56.789000'
    efci.LocalDateTime = '1985-10-26T01:20:00'
    assert efci.LocalDateTime == '1985-10-26T01:20:00'

    with caplog.at_level(logging.INFO, 'sarpy.io.product.sidd3_elements.ExploitationFeatures'):
        efci.LocalDateTime = 1234
        assert efci.LocalDateTime is None
        assert caplog.records


def test_exploitation_features_collection_information_from_sicd_error():
    with pytest.raises(TypeError):
        ef3.ExploitationFeaturesCollectionInformationType.from_sicd(None)


@pytest.fixture(scope='module')
def sicd():
    tests_dir = pathlib.Path(__file__).parent.parent.parent.parent
    xml_file = tests_dir / 'data' / 'example.sicd.xml'
    structure = SICDType().from_xml_file(xml_file)

    return structure


def test_from_sicd(sicd):
    features = ef3.ExploitationFeaturesType.from_sicd(
        sicd,
        sicd.RadarCollection.Area.Plane.XDir.UVectECF.get_array(),
        sicd.RadarCollection.Area.Plane.YDir.UVectECF.get_array())

    assert features.Collections[0].Geometry.Azimuth == pytest.approx(sicd.SCPCOA.AzimAng)
    layover_cw_from_col = (sicd.SCPCOA.LayoverAng - sicd.SCPCOA.AzimAng - 90) % 360
    assert features.Collections[0].Phenomenology.Layover.Angle == pytest.approx(layover_cw_from_col, abs=0.01)
